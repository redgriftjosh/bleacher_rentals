
  create table "public"."AccountManagers" (
    "account_manager_id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" bigint not null,
    "is_active" boolean not null default true
      );


alter table "public"."AccountManagers" enable row level security;

alter table "public"."Bleachers" add column "summer_account_manager_id" bigint;

alter table "public"."Bleachers" add column "winter_account_manager_id" bigint;

alter table "public"."Drivers" add column "account_manager_id" bigint;

alter table "public"."Drivers" add column "is_active" boolean not null default true;

CREATE UNIQUE INDEX "AccountManagers_pkey" ON public."AccountManagers" USING btree (account_manager_id);

CREATE UNIQUE INDEX "AccountManagers_user_id_key" ON public."AccountManagers" USING btree (user_id);

CREATE UNIQUE INDEX "Drivers_user_id_key" ON public."Drivers" USING btree (user_id);

alter table "public"."AccountManagers" add constraint "AccountManagers_pkey" PRIMARY KEY using index "AccountManagers_pkey";

alter table "public"."AccountManagers" add constraint "AccountManagers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public."Users"(user_id) not valid;

alter table "public"."AccountManagers" validate constraint "AccountManagers_user_id_fkey";

alter table "public"."AccountManagers" add constraint "AccountManagers_user_id_key" UNIQUE using index "AccountManagers_user_id_key";

alter table "public"."Bleachers" add constraint "Bleachers_summer_account_manager_id_fkey" FOREIGN KEY (summer_account_manager_id) REFERENCES public."AccountManagers"(account_manager_id) not valid;

alter table "public"."Bleachers" validate constraint "Bleachers_summer_account_manager_id_fkey";

alter table "public"."Bleachers" add constraint "Bleachers_winter_account_manager_id_fkey" FOREIGN KEY (winter_account_manager_id) REFERENCES public."AccountManagers"(account_manager_id) not valid;

alter table "public"."Bleachers" validate constraint "Bleachers_winter_account_manager_id_fkey";

alter table "public"."Drivers" add constraint "Drivers_account_manager_id_fkey" FOREIGN KEY (account_manager_id) REFERENCES public."AccountManagers"(account_manager_id) not valid;

alter table "public"."Drivers" validate constraint "Drivers_account_manager_id_fkey";

alter table "public"."Drivers" add constraint "Drivers_user_id_key" UNIQUE using index "Drivers_user_id_key";

grant delete on table "public"."AccountManagers" to "anon";

grant insert on table "public"."AccountManagers" to "anon";

grant references on table "public"."AccountManagers" to "anon";

grant select on table "public"."AccountManagers" to "anon";

grant trigger on table "public"."AccountManagers" to "anon";

grant truncate on table "public"."AccountManagers" to "anon";

grant update on table "public"."AccountManagers" to "anon";

grant delete on table "public"."AccountManagers" to "authenticated";

grant insert on table "public"."AccountManagers" to "authenticated";

grant references on table "public"."AccountManagers" to "authenticated";

grant select on table "public"."AccountManagers" to "authenticated";

grant trigger on table "public"."AccountManagers" to "authenticated";

grant truncate on table "public"."AccountManagers" to "authenticated";

grant update on table "public"."AccountManagers" to "authenticated";

grant delete on table "public"."AccountManagers" to "postgres";

grant insert on table "public"."AccountManagers" to "postgres";

grant references on table "public"."AccountManagers" to "postgres";

grant select on table "public"."AccountManagers" to "postgres";

grant trigger on table "public"."AccountManagers" to "postgres";

grant truncate on table "public"."AccountManagers" to "postgres";

grant update on table "public"."AccountManagers" to "postgres";

grant delete on table "public"."AccountManagers" to "service_role";

grant insert on table "public"."AccountManagers" to "service_role";

grant references on table "public"."AccountManagers" to "service_role";

grant select on table "public"."AccountManagers" to "service_role";

grant trigger on table "public"."AccountManagers" to "service_role";

grant truncate on table "public"."AccountManagers" to "service_role";

grant update on table "public"."AccountManagers" to "service_role";


  create policy "Allow All for Auth"
  on "public"."AccountManagers"
  as permissive
  for all
  to authenticated
using (true);

-- Add is_admin to Users
alter table public."Users"
  add column is_admin boolean not null default false;

-- Backfill existing rows: admins are those with role = 2
update public."Users"
set is_admin = (role = 2);

create or replace function public.users_sync_is_admin()
returns trigger
language plpgsql
as $$
begin
  if NEW.role = 2 then
    NEW.is_admin := true;
  else
    NEW.is_admin := false;
  end if;

  return NEW;
end;
$$;

-- drop trigger if exists users_sync_is_admin on public."Users";

create trigger users_sync_is_admin
before insert or update of role
on public."Users"
for each row
execute function public.users_sync_is_admin();

comment on column public."Users".role is
  'DEPRECATED: superseded by is_admin. Do not use in new code.';

-- Sync role based on is_admin changes
create or replace function public.users_sync_role_from_is_admin()
returns trigger
language plpgsql
as $$
declare
  v_is_account_manager boolean;
  v_is_driver boolean;
begin
  -- Only proceed if is_admin changed
  if NEW.is_admin = OLD.is_admin then
    return NEW;
  end if;

  if NEW.is_admin = true then
    -- User became admin, set role to 2
    NEW.role := 2;
  else
    -- User is no longer admin, determine role based on AccountManagers and Drivers tables
    
    -- Check if user is an account manager
    select exists(
      select 1 from public."AccountManagers" 
      where user_id = NEW.user_id
    ) into v_is_account_manager;
    
    -- Check if user is a driver
    select exists(
      select 1 from public."Drivers" 
      where user_id = NEW.user_id
    ) into v_is_driver;
    
    if v_is_account_manager then
      -- User is an account manager
      NEW.role := 1;
    elsif v_is_driver then
      -- User is a driver
      NEW.role := 3;
    else
      -- User is neither, default to account manager role
      NEW.role := 1;
    end if;
  end if;

  return NEW;
end;
$$;

-- drop trigger if exists users_sync_role_from_is_admin on public."Users";

create trigger users_sync_role_from_is_admin
before update of is_admin
on public."Users"
for each row
execute function public.users_sync_role_from_is_admin();

-- Backfill AccountManagers table: create records for all users with role = 1 (Account Manager)
insert into public."AccountManagers" (user_id)
select user_id
from public."Users"
where role = 1 or role = 2
  and not exists (
    select 1 
    from public."AccountManagers" 
    where "AccountManagers".user_id = "Users".user_id
  );